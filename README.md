# FileSys - 多线程文件系统模拟器

这是一个用C语言实现的多线程文件系统模拟程序，基于简单文件系统模拟器，增加了多线程支持和生产者-消费者模型，旨在演示并发文件系统操作和磁盘管理机制。

## 项目概述

### 项目背景
FileSys 是一个用C语言实现的多线程文件系统模拟程序，旨在演示基本的文件系统操作、磁盘管理机制以及并发控制。

### 目标用户
学习操作系统、文件系统原理和多线程编程的学生或开发者。

### 核心问题
模拟底层磁盘存储管理、文件操作（如创建、读写、删除等）以及并发控制机制，帮助理解文件系统内部工作原理。

## 新增功能

### 多线程支持
1. **生产者-消费者模型**：
   - 主线程作为生产者，负责接收用户命令并将其转化为任务
   - 多个消费者线程负责执行具体的文件操作任务
   - 通过任务队列协调生产者和消费者之间的协作

2. **并发控制**：
   - 使用互斥锁保护共享资源（文件系统状态）
   - 使用条件变量实现线程间同步
   - 实现线程安全的文件操作

3. **新命令支持**：
   - `copy <src> <dest>` - 复制文件
   - `test` - 运行压力测试，创建50个并发文件操作任务

### 文件操作增强
1. **文件复制功能**：支持在文件系统内部复制文件
2. **压力测试功能**：可模拟高并发场景下的文件操作

## 模块框架设计

这个文件系统模拟器由三个主要模块组成：

1. **主控模块(main.c)**：
   - 用户界面处理
   - 命令解析和任务分发
   - 程序初始化和终止
   - 线程管理

2. **磁盘管理层(disk.c/disk.h)**：
   - 磁盘镜像文件管理
   - 块级读写操作
   - 磁盘元数据管理（超级块、位图等）

3. **文件操作层(file_ops.c/file_ops.h)**：
   - 文件系统操作实现
   - 文件和目录管理
   - inode和数据块分配/释放
   - 并发控制

模块间关系如下：
```
+------------------+
|     main.c       | (用户接口层 - 生产者)
+--------+---------+
         |
         | (任务队列)
         v
+------------------+     +------------------+
|  消费者线程1     | ... |  消费者线程N     |
+--------+---------+     +--------+---------+
         |                        |
         v                        v
+-------------------------------------------+
|            file_ops.c                     | (文件系统逻辑层)
|  (带锁API)                                |
+--------------------+----------------------+
                     |
                     v
+-------------------------------------------+
|            file_ops.c                     | (文件系统核心逻辑)
|  (无锁内部函数)                           |
+--------------------+----------------------+
                     |
                     v
+-------------------------------------------+
|              disk.c                       | (磁盘存储层)
+-------------------------------------------+
```

## 流程图

### 程序主流程：
```mermaid
graph TD
    A[程序启动] --> B[初始化磁盘和锁]
    B --> C[创建消费者线程]
    C --> D[显示帮助信息]
    D --> E[等待用户输入]
    E --> F[解析命令]
    F --> G{命令类型}
    
    G -->|普通命令| H[创建任务并入队]
    G -->|test| I[创建50个测试任务并入队]
    G -->|exit| J[设置运行标志为false]
    
    H --> E
    I --> E
    J --> K[广播唤醒所有线程]
    K --> L[等待所有消费者线程退出]
    L --> M[清理资源并退出]
```

### 消费者线程处理流程：
```mermaid
graph TD
    A[线程启动] --> B[检查运行标志]
    B --> C{运行标志为真?}
    C -->|是| D[获取队列锁]
    D --> E{队列为空?}
    E -->|是| F[等待条件变量]
    E -->|否| G[从队列取出任务]
    G --> H[释放队列锁]
    H --> I[执行任务]
    I --> B
    
    C -->|否| J[释放队列锁]
    J --> K[线程退出]
```

### 文件操作流程（以创建文件为例）：
```mermaid
graph TD
    A[调用create_file] --> B[获取文件系统锁]
    B --> C[读取根目录inode]
    C --> D[调用内部_create_file]
    D --> E[查找同名文件]
    E --> F{文件已存在?}
    F -->|是| G[返回错误]
    F -->|否| H[查找空闲目录项]
    H --> I[分配inode]
    I --> J[初始化inode]
    J --> K[更新目录项]
    K --> L[写回磁盘]
    L --> M[释放文件系统锁]
    M --> N[返回成功]
    
    G --> M
```

## 核心数据结构

### 1. 多线程相关结构体

#### task_t (任务结构体)
```c
typedef struct {
    command_e cmd;          // 命令类型
    char arg1[MAX_ARG_LEN]; // 参数1
    char arg2[MAX_ARG_LEN]; // 参数2
    char content[1024];     // 文件内容（用于echo命令）
} task_t;
```

#### command_e (命令枚举)
```c
typedef enum {
    CMD_HELP,
    CMD_FORMAT,
    CMD_DF,
    CMD_TOUCH,
    CMD_RM,
    CMD_LS,
    CMD_CAT,
    CMD_ECHO,
    CMD_COPY,
    CMD_TEST, // 压力测试
    CMD_UNKNOWN
} command_e;
```

### 2. 磁盘相关结构体

#### inode_t (索引节点)
```c
typedef struct {
    uint32_t size;        // 文件大小
    uint16_t type;        // 文件类型 (1: 普通文件, 2: 目录)
    uint16_t links;       // 链接计数
    uint32_t blocks[8];   // 直接数据块指针 (最多8个块)
} inode_t;
```

#### superblock_t (超级块)
```c
typedef struct {
    uint32_t magic;                  // 魔数标识
    uint32_t blocks;                 // 总块数
    uint32_t inode_blocks;           // inode区占用块数
    uint32_t data_blocks;            // 数据区可用块数
    uint32_t free_inode_count;       // 空闲inode数
    uint32_t free_data_count;        // 空闲数据块数
    char padding[BLOCK_SIZE - 6*sizeof(uint32_t) - sizeof(uint16_t)];
    uint16_t state;                  // 文件系统状态
} superblock_t;
```

#### filesystem_t (文件系统实例)
```c
typedef struct {
    FILE* file;                           // 磁盘映像文件句柄
    superblock_t superblock;              // 超级块缓存
    char inode_bitmap[INODE_BLOCKS * BLOCK_SIZE];  // inode位图缓存
    char data_bitmap[DATA_BLOCKS / 8];    // 数据块位图缓存
} filesystem_t;
```

### 3. 文件系统相关结构体

#### dir_entry_t (目录项)
```c
typedef struct {
    uint32_t inode;              // inode编号
    char name[MAX_FILENAME];     // 文件名
} dir_entry_t;
```

### 4. 全局变量

```c
filesystem_t fs;                // 全局文件系统实例
pthread_mutex_t fs_lock;        // 文件系统全局锁
pthread_mutex_t queue_lock;     // 任务队列锁
pthread_cond_t queue_not_empty; // 队列非空条件变量
pthread_cond_t queue_not_full;  // 队列非满条件变量
```

## 系统功能

### 主要功能:
- 磁盘模拟：通过 `disk.c` 实现虚拟磁盘的初始化与读写。
- 文件操作：通过 `file_ops.c` 提供文件的创建、打开、读取、写入、关闭和删除等功能。
- 文件复制：支持在文件系统内部复制文件。
- 压力测试：可模拟高并发场景下的文件操作。
- 主程序控制：`main.c` 提供入口，调用相关接口进行测试和验证。

### 关键特性:
- 使用内存模拟磁盘块。
- 支持基本的文件系统元数据管理（如 inode、目录结构等）。
- 多线程支持，采用生产者-消费者模型处理并发请求。
- 线程安全的文件操作。
- 可调试和扩展性强，适合教学用途。

## 技术架构

### 设计模式:
- 模块化设计：将功能划分为磁盘层（disk）、文件操作层（file_ops），实现分层抽象。
- 过程式编程：采用C语言的过程式风格组织代码逻辑。
- 生产者-消费者模式：主线程作为生产者，多个工作线程作为消费者。
- 读写锁分离：将线程安全接口与核心逻辑分离。

### 主要组件交互:
- `main.c` 解析用户命令并将其封装为任务放入任务队列。
- 消费者线程从任务队列获取任务并调用 `file_ops.c` 中的文件操作函数。
- `file_ops.c` 提供带锁的公共API和无锁的内部函数，调用 `disk.c` 提供的底层读写接口来访问"磁盘"数据。
- `disk.c` 管理一块模拟的连续内存空间，代表物理磁盘。

## 技术选型
- 编程语言: C
- 编译器: GCC
- 标准: C99
- 构建工具: Make
- 多线程支持: POSIX Threads (pthreads)

## 开发环境
### 必需工具:
- GCC 编译器
- GNU Make
- 支持 C99 和 pthread 的开发环境（如 Linux、macOS 或 Windows + MinGW/WSL）

### 运行环境:
- 构建命令: `make` （生成 filesystem 可执行文件）
- 清理命令: `make clean` （删除目标文件和可执行文件）
- 本地开发: 直接编辑源码后使用 make 构建

## 使用说明

1. 构建项目:
   ```bash
   make
   ```

2. 运行程序:
   ```bash
   ./filesystem
   ```

3. 常用命令:
   - `format` - 格式化磁盘
   - `df` - 显示磁盘信息
   - `touch <文件名>` - 创建文件
   - `rm <文件名>` - 删除文件
   - `ls` - 列出目录内容
   - `cat <文件名>` - 读取文件内容
   - `echo <文件名>` - 写入文件内容
   - `copy <源文件> <目标文件>` - 复制文件
   - `test` - 运行压力测试
   - `help` - 显示帮助信息
   - `exit` - 退出程序

## 磁盘镜像管理机制

- 当 disk.img 文件不存在时，程序启动会自动创建新的 2MB 磁盘镜像文件
- 需执行 `format` 命令初始化文件系统结构（超级块、inode位图、数据块位图等）
- 完整流程：删除旧文件 → 启动程序 → 执行 format 命令

## 并发控制机制

### 锁机制
- 全局文件系统锁（fs_lock）：保护所有文件系统操作
- 任务队列锁（queue_lock）：保护任务队列的读写操作

### 条件变量
- queue_not_empty：当任务队列为空时，消费者线程等待此条件变量
- queue_not_full：当任务队列满时，生产者线程等待此条件变量

### 线程安全设计
1. 所有公共API函数都获取全局文件系统锁
2. 内部无锁函数供已获取锁的函数调用
3. 任务队列操作使用专门的锁和条件变量